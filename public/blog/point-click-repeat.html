<!--
::metadata::
id: point-click-repeat
title: Point, Click, Repeat
displayTitle: Point, Click, Repeat: The Slow Death of Productive Interfaces
date: 2026-01-24
summary: We obsess over system latency while ignoring human latency. Good interfaces respect muscle memory.
::/metadata::
-->
<p>Let me start by making something clear: I’m usually a pretty nostalgic and romantic type when it comes to old technology, but I’ve made an effort to leave nostalgia behind.</p>

<p>This is about science, human nature, and efficiency.</p>

<p>There was a time when the keyboard was the primary interface between human intent and machine execution. Terminals, editors, early IDEs — they all assumed one thing:</p>
<p>If you’re using this tool, you mean business.</p>

<p>You know, the keyboard isn’t just an input device; it is an extension of cognition, and more importantly, it takes advantage of something fundamental about how humans work and operate: muscle memory.</p>

<p>When you use a keyboard-centric tool regularly, your hands learn the layout. They memorize common commands, sequences, and patterns.</p>

<p>Back in the day, you didn’t think about how to save, navigate, refactor, search, or execute. Your hands knew. Actions lived below conscious thought, the same way a pianist doesn’t spell out each note or a driver doesn’t verbally plan every gear change.</p>

<p>That’s what real productivity feels like: intent → action, with no translation layer in between.</p>

<p>Then the web happened.</p>

<p>HTML was built to display documents, not orchestrate workflows. Links, buttons, forms — everything optimized for clicking. And as web apps took over software, mouse-first interfaces became the default.</p>
<p>Not because they were better. Because they were easier to build. Frameworks, libraries, and standardization all favored point-and-click.</p>

<p>Applications built by teams of developers following requirements and instructions — not crafted by single artisans with a vision and goal anymore, solving their own problems in the first place.</p>

<p>Keyboard interaction became optional. Shortcuts were added late, inconsistently, or not at all. Focus states broke. Power paths disappeared. And slowly, we normalized interfaces where every action required a visual search, a pointer movement, and a click.</p>

<p>When every interaction forces you to look, aim, and confirm, your hands never learn. You stay in a permanent beginner mode — even after years of daily use.</p>

<p>This wasn’t user-centric design. It was developer-centric convenience.</p>

<p>And I’ve felt this painfully in my own work.</p>

<p>I grew up with tools such as Norton Commander or Midnight Commander, years using terminals, editors, and tools where my hands move faster than my thoughts. Where deploying, navigating logs, editing config, or jumping between systems is almost subconscious. Flow is real there — you feel it when everything is right at your fingertips.</p>

<p>Then I open a modern web dashboard.</p>

<p>Suddenly I’m hunting.<br />
Where’s that button?<br />
Which tab was it under?<br />
Why can’t I just do the thing?</p>

<p>I’m slower — not because the system is complex, but because the interface refuses to meet me halfway. Every action pulls me out of flow and back into decision-making mode. It feels less like operating a system and more like filling out paperwork.</p>

<p>And yet, the most efficient human–computer interfaces ever created never abandoned the keyboard.</p>

<p>Real-time strategy games like Warcraft and StarCraft demand hundreds of actions per minute. Players issue commands faster than menus can render. Keyboard for intent. Mouse for spatial precision. No friction. No ceremony.</p>

<p>Crucially, these games train muscle memory relentlessly. Hotkeys are stable. Actions are consistent. Over time, the interface disappears entirely.</p>

<p>That same model applies everywhere else. IDEs. Terminals. Admin tools. Even complex business software. When keyboard and mouse work together, productivity spikes. When the keyboard is sidelined, humans slow down.</p>

<p>We obsess over system latency while ignoring human latency. Every unnecessary click, every forced context switch, every modal dialog taxes attention. Over a day, a week, a career — that cost compounds brutally.</p>

<p>Good interfaces respect muscle memory. They assume the user will come back tomorrow. And the day after. And the year after that.</p>

<p>They make common actions effortless, discoverable once, and automatic forever.</p>

<p>The mouse should refine intent, not create it.</p>

<p>The keyboard didn’t become obsolete. We didn’t outgrow it.</p>
<p>We simply stopped designing for people who actually use their tools — and in doing so, slowed everyone down.</p>

<p>Long live the keyboard.</p>
<div class="meta">- P.</div>
